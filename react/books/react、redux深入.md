# react、redux学习
## react
### 1、初识
- create-react-app在构建时帮忙引入react项目基本所需的包
- JSX：js语法扩展(extension)
- - JSX是进步还是倒退？本着前端逻辑上分而治之的原则，将一个页面分为内容-html、样式-css、交互-js三大部分，然后由于页面的复杂性，导致一个页面js对dom操作越来越频繁，虽然浏览器内核也变得越来越强大（异步事件线程），足以支持相当数量的异步事件监听。但是前端的dom对象也越来越复杂，因此有必要使用js将一个dom对象映射成一个js对象，减小交互带来的性能消耗。相比之前的三大分治的原则，jsx将html和js合为一体更符合未来页面交互复杂化的趋势，更有利于减少交互带来的内存泄漏、页面性能损耗（一切采用js进行一定的优化）。
- 判断组件、元素的原则：根据命名是否大写来确定
- 声明式编程、命令式编程对比
- - 命令式编程：开发人员利用编程的手段，告诉计算机指令，计算机做出相对应的反应与改变。（代码量大，主要是得事无巨细的告诉计算机各条指令）
- - 声明式编程：也是编程，但是在一套已经有了成熟指令的框架里面编程，只需要少部分代码告诉框架，框架将其优化，翻译成指令告诉计算机，更少的代码做更多的事。（过程主要由制造框架的人将其常见需求作成优化的计算机指令，达到节省代码、优化性能的目的）（站在巨人肩上编程）（一般来说只用管理事件和数据就行，渲染完全交给框架去发出指令执行）
- 虚拟DOM：利用对象特性，对dom树的进行抽象表现。dom树是html文档的抽象表现
### 2、设计高质量的组件
#### 1、划分组件边界的原则
- 高内聚：把逻辑紧密相关的内容放在一个组件中
- 低耦合：每个组件要最大化保持独立，尽可能不互相依赖（看传入的props）。根据功能点（重点）（每个组件都有独一无二的功能点）进行划分模块。
- 让一个组件只做一件事。如果发现一个组件做了多件事。就把它划分开来。
#### 2、react组件的数据种类
- props：外部数据接口（公用数据和方法）（开发中定义注意使用propTypes，生产时将其去掉，使用babel-react-optimize）（组件不应该改变props的值(pure写法)）
- state：内部数据管理（管理内部独一无二的数据）
#### 3、react组件的生命周期
- 装载过程(Mount)：组件第一次在dom树中渲染过程
- - constructor：es6新增class特性（类似寄生组合继承的方式？）主要用来初始化state、cclass的静态变量、绑定事件监听的this
- - getInitialState：state初始化，淘汰
- - getDefaultProps：props进行初始化赋值（淘汰），现在采用defaultProps直接进行赋值
- - componentWillMount：render之前调用。不会触发重绘。基本不能做什么事，需要提前做的可以放到constructor。不急的，放到DidMount中去。
- - render：最重要的函数之一。返回一段JSX的数据结构（内容）。通过babel解析。react来渲染。渲染过程应该是使用createElement渲染。
- - componentDidMount：render之后调用，是一个装载过程的收尾。要在父级组件开始收尾的时候，身为子组件会按加载顺序一个个收尾。与其兄弟WillMount还有一个区别是它只能在浏览器端生效，服务端无效。
- 更新过程(Update)：当组件重新渲染的过程
- - componentWillReceiveProps：当父组件render执行时，子组件会发生这个事件。因此要做props的相关的限制。不然会导致重复执行，浪费性能。组件本身的setState不会触发这个事件
- - shouldComponentUpdate：重要程度仅次于render函数，也是和render函数并称react唯一硬性要求有返回结果的函数。其返回一个boolean值，决定此次更新过程是否继续，在这可以完善逻辑，达到节省性能的目的。（提高性能，优化项目时必须要考虑使用到它）
- - componentWillUpdate：类似装载过程
- - render：类似装载过程
- - componentDidUpdate：在浏览器端和服务端都可以生效
- 卸载过程(Unmount)：组件从DOM树中删除的过程
- - 唯一函数componentWillMount：做清理性工作，防止内存泄漏
#### 4、state和props的局限
- 容易出现重复数据。不一致的场景难以抉择。可能出现数据重复和冗余
## redux
### 1、单向数据流始祖Flux
- 单向数据流：view发起action，dispatch分发，store数据更改，重新渲染view。主要就是为了追踪数据变化，防止维护代码出现不可预测未知的bug
- 缺点：store不仅需要维护数据还要处理数据变化的逻辑
- 优点：第一次提出了单向数据流的工作模式
- MVC的缺陷：
- - 当一个项目复杂化，充斥大量的view和model。很有可能会出现view和model直接对话的情况的出现。这样会导致项目到后期越来越难以维护，代码越来越复杂化，难以改动。
### 2、Flux的更强实现Redux
- 三大原则：
- - 唯一数据源：只存在一颗store树，储存所有state数据
- - 保持状态只读：只能通过dispatch(action)的方式修改数据
- - 数据改变只能使用reducer：纯函数进行改变
### 3、React与Redux结合
- 使用react-redux。观看connect、Provider的源码
## 模块化应用
### 1、要点
- 构建网页应用时必须考虑清楚的点
- - 代码文件的组织结构
- - 模块边界
- - Store的状态树设计
### 2、代码文件的组织方式
- 按角色组织：按代码功能分类组织
- 按功能组织：按交互功能分类组织
### 3、模块接口
- 利用es6 import、export机制将代码文件进行分类组件再统一通过index.js的默认机制进行导出，暴露外部接口
### 4、状态树的设计
- 原则：
- - 一个模块控制一个状态节点（一个reducer对应一个模块。reducer修改互斥）
- - 避免冗余数据（保持数据一致性？）
- - 树形结构扁平（由于js的undefined特性，建议编写任何js数据结构都应该尽量扁平化数据）
## 源码地址：github.com/mocheng/react-and-redux